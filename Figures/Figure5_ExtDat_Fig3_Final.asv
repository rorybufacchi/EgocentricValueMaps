% -----
% USE:
% 
% - Run this script to re-create:
% -- The elements used for making Figure 5 of the main paper
% -- The statistical results related to Figure 5
% -- By changing the options to load the 'small nets' data, this script
%    also recreates the elements of extended data figure 3
%
% - The data necessary for this figure is generated by CreateDataForPlots_Final.m,
% but a pre-computed version can also be loaded from:
% load('Results\ForFigures\$$$\$$$.mat') $
% -----


% First make sure the path is set right
cFileName       = matlab.desktop.editor.getActiveFilename;
codePath        = cFileName(1:end-35);
addpath(genpath(codePath));

% NOTE: Change this to the file path where you store the generated data,
% whether downloaded or generated by yourself
dataPath        = '';
if              isempty(dataPath)
     dataPath       = SetPathEgocentricMapsData();
end
cd(             dataPath);


%% LOAD DATA for Fig5, abcd
% NOTE: Load this if not computing the ANN outputs yourself

% NOTE: to create the elements of Extended Data Figure 3, set this to
% 'SmallNets' instead
netSize = 'BigNets'; % Alternative: 'SmallNets'

try
    load(['Results\ForFigures\Fig5_ExtDatFig3_model6_Base_Processed_' netSize '_Precomputed.mat' ]);
catch
    warning('No Precomputed data found. Either Compute results using CreateDataForPlots.m, or download precompted results from $')
end

%% STATS: proportion of networks that show structure

pTmp        = pNodeDists(:,1:15);
tStatTmp    = tStatsStructure(:,1:15); 

[pValThr, pValcor, pValLMEAdj] = fdr(pTmp(:));


fprintf('%i out of %i networks show structure using neuron-distance metric \n', sum(pValLMEAdj(:) < 0.05), numel(pValLMEAdj));

dimsToSum = [1 2];

disp(['Weighted mean tstat of node distance ' num2str(mean(tStatTmp(:))) '+-' num2str(std(tStatTmp(:)))]);


%% STATS: Proportion of networks that show orthogonality

iD = 1; iV = 1;

for iTyp = 1:length(neurTypes)
for iReg = 1:length(regTypes)
for iRun = 1:size(rSall,2)
for iM = 1:size(rSall,1)

    try
    [pTmp,hTmp,stats] = signrank( ...
        abs(squeeze(alldotProdBs(iM,iRun,iTyp,iReg,iD,iV,:))),  ...
    abs(cos(deg2rad(75))) ...
    ,'method','approximate','tail','left');
    pValBootstrapPCA(iM,iRun,iTyp,iReg,iD,iV) = pTmp;
    signRankPCA(iM,iRun,iTyp,iReg,iD,iV) = stats.signedrank;
    zPCA(iM,iRun,iTyp,iReg,iD,iV) = stats.zval;
    catch
        pValBootstrapPCA(iM,iRun,iTyp,iReg,iD,iV) = 1;
        signRankPCA(iM,iRun,iTyp,iReg,iD,iV) = 0;
        zPCA(iM,iRun,iTyp,iReg,iD,iV) = 0;
    end

end
end
end
end

% Only inlcude the default networks composed of tansig units for count of
% networks showing structure
tmpP = pValBootstrapPCA(:,1:15);
tmpCos = alldotProd(:);
tmpSin = sin(acos(alldotProd(:)));

[pValThr, pValcor, pValPCAAdj] = fdr(tmpP(:));

fprintf('%i out of %i networks show orthogonality \n', sum(pValPCAAdj(:) < 0.05), numel(pValPCAAdj));


disp(' ')
meanAng = rad2deg(atan2(mean(tmpSin(~isnan(tmpSin))) , mean(tmpCos(~isnan(tmpSin)))));
sdAng = rad2deg(atan2(std(tmpSin(~isnan(tmpSin))) , std(tmpCos(~isnan(tmpSin)))));
disp(['Mean encoding angle: ' num2str(meanAng) 'deg +- ' num2str(sdAng) 'deg SD']);



%% STATS: correlations between structure and performance

tStatsStructureTmp = tStatsStructure(:,1:15,:,:,:);
allPerfTmp         = allPerf(:,1:15,:,:,:);
[rhoStruct pStruct] = corr(tStatsStructureTmp(:),allPerfTmp(:));
[r_low, r_high] = corrCI(rhoStruct, numel(tStatsStructureTmp(:)), 0.05);

disp('correlation between structure t-stat and network performance: ');
disp(['P = ' num2str(pStruct) '. rho = ' num2str(rhoStruct) ' (95% CI: ' num2str(r_low) '-' num2str(r_high)]);


%% STATS: relationship between orthogonality and performance

absalldotProd = abs(alldotProd);
absAllDotProbTmp = absalldotProd(:,1:15,:,:,:);
disp('correlation between functional orthogonality and network performance')
[rhoOrth pOrth] = corr(absAllDotProbTmp(~isnan(absAllDotProbTmp(:))),allPerfTmp(~isnan(absAllDotProbTmp(:))));
[r_low, r_high] = corrCI(rhoOrth, numel(absAllDotProbTmp(:)), 0.05);
disp(['P = ' num2str(pOrth) '. rho = ' num2str(rhoOrth) ' (95% CI: ' num2str(r_low) '-' num2str(r_high)]);


%% Fig5a - example network


for iRun = 2 %1:15
for iM = 1 %1:3 

    f.ExampleNetwork.f = figure('Position',[50 250 1000 400]);
    sgtitle(['Example of sub-network formation. Architecture ' num2str(iM) '/3, Run ' num2str(iRun) '/15']);
    
    netAR = allNetAR(iM,iRun);


    % ==============================================================
    % Show network connections    
    subplot(1,2,1);
    p = plot(netAR.G,'Layout','force','WeightEffect','inverse','UseGravity','on');
    
    % Make an indicator of layer depth
    tmp = netAR.A_B_rat';
    layNum = [1:size(netAR.A_B_rat,1)] .*    ones(size(tmp));
    layNum = layNum(:);
    layNum(isnan(tmp(:))) = [];

    % Define colour
    A_B_rat = NanRemFlatten(netAR.A_B_rat'); classType = 'rat';
%     A_B_rat = NanRemFlatten(netAR.A_B_diff'); classType = 'diff';
%     A_B_rat = NanRemFlatten(netAR.AorB'); classType = 'bool';
    G = netAR.G;
   
    tmpX = p.XData;
    tmpY = p.YData;

   
    % ==============================================================
    % Show background colour depicting local network type
    
    % For non-rotated x and y
    nBinsX = 100;
    nBinsY = 100;
    sgm = 5;
    sz  = 15;
    
    myGausFilt = images.internal.createGaussianKernel([sgm sgm], [sz sz]);
    
    binXw = (max(tmpX) - min(tmpX))./nBinsX;
    binYw = (max(tmpY) - min(tmpY)) ./nBinsY;
    
    % Binned neural preferences
    binNP  = nan([nBinsX nBinsY]);
    binNPF = nan([nBinsX nBinsY]);
    binCsx = linspace(min(tmpX),max(tmpX),nBinsX);
    binCsy = linspace(min(tmpY),max(tmpY),nBinsY);
    
    for iBx = 1:nBinsX
        inX =   tmpX >= binCsx(iBx) - binXw ./2 & ...
            tmpX <= binCsx(iBx) + binXw ./2 ;
        for iBy = 1:nBinsY
            inY =   tmpY >= binCsy(iBy) - binYw ./2 & ...
                tmpY <= binCsy(iBy) + binYw ./2 ;
            
            if strcmp(classType,'diff')
                binNP(iBx,iBy) = nansum(A_B_rat(inX & inY));
            elseif strcmp(classType,'rat') | strcmp(classType,'bool')
                binNP(iBx,iBy) = nansum(A_B_rat(inX & inY) - .5);
            end
        end
    end
    
    %  Pad binNP so that it can be convolved nicely
    tmpPad = nan(size(binNP) + [1 1] .*2 .* ceil(sz/2));
    tmpPad(ceil(sz/2) + 1 : end - ceil(sz/2) , ceil(sz/2) + 1 : end - ceil(sz/2) ) = binNP;
    
    % Other filter isn't working well. Make my own filtered version with hookers and cocaine
    basePoint = ceil(sz/2) + 1;
    for iBx = 1:nBinsX
        for iBy = 1:nBinsY
            binNPF(iBx,iBy) = nansum(tmpPad(basePoint + [iBx - floor(sz/2) : iBx + floor(sz/2)] , ...
                basePoint + [iBy - floor(sz/2) : iBy + floor(sz/2)]  ) .* ...
                myGausFilt, 'all');
        end
    end

    subplot(1,2,2);
    ImagescInvisNan(1,binCsx,binCsy,binNPF')
    axis xy
    colormap(redbluecmapRory(5,6))
    SymColAxis;
    colorbar
    hold on
    scatter(tmpX ,tmpY ,50,[.5+A_B_rat zeros(size(A_B_rat)) .5-A_B_rat], ...
        'o','Filled','MarkerFaceAlpha',.5,'MarkerEdgeAlpha',.0,'MarkerEdgeColor','w')
    scatter(tmpX ,tmpY ,50,[A_B_rat zeros(size(A_B_rat)) 1-A_B_rat], ...
        'o','Filled','MarkerFaceAlpha',.5,'MarkerEdgeAlpha',.0,'MarkerEdgeColor','w')
    
    colormap(redbluecmapRory(100,10))

end
end


%% Figure 5b & d: - Relationship between subnetwork structure and task performance,
%                 - Encoding angle polar plot
%
% NOTE: if running small nets, this also plots the data from extended data
% fig 3

metDefs = {'tStatsStructure'};
yDefs   = {'allPerf'        };

rowDefs = neurTypes;
for iReg =1:length(regTypes)
    f.(['StructureVsReward' regTypes{iReg}]).f        = figure('Position',[50,20,300,1800]); 
for iRow = 1:numel(rowDefs) 
for iMet = 1:length(metDefs)

    % Now scatter plot with side histograms
    eval([' tmpX = ' metDefs{iMet} '(:,1:15,' num2str(iRow) ',' num2str(iReg) ');']);
    eval([' tmpY = ' yDefs{iMet}   '(:,1:15,' num2str(iRow) ',' num2str(iReg) ');']);
    tmpX = tmpX(:);
    tmpY = tmpY(:);


    axS.xOffset = 0.05;
    axS.yOffset = 0.05;

    axS.xSpace  = 0.4./length(metDefs);
    axS.ySpace  = 0.4./length(rowDefs);

    ax{1} = axes('Position',[axS.xOffset + ...
        axS.xSpace  + (iMet-1) .* ((1 - 2.*axS.xOffset) ./ length(metDefs)) , ...
        axS.yOffset + (iRow-1) .* ((1 - 2.*axS.yOffset) ./ length(rowDefs)), ...
        (  ((1 - 2.*axS.xOffset) ./ length(metDefs)) - axS.xSpace ) , ...
        (  ((1 - 2.*axS.yOffset) ./ length(rowDefs)) - axS.ySpace ) ]);

    plot(tmpX,tmpY,'.')
    set(ax{1},'Visible','off')
    yLims = [-.1 .1];
    ylim(yLims)

    xLims = [-20 20];
    if iMet == 1
        xlim(max(abs(xLims)) .* [-1 1] );
        xLims = xlim;
    end
    lsline

    ax{2} = axes('Position',ax{1}.Position .* [1 1 1 0] + [0 -axS.ySpace.*.9 0 axS.ySpace.*.9] + [0 axS.ySpace+ax{1}.Position(4) 0 0] );
    h = histogram(tmpX,linspace(xLims(1),xLims(2),11)); hold on
    box off
    xlim(xLims);
    [splineHandle] = PlotHistSpline(h,'LineWidth',2,'Color','b')
    title(CorrelationTitle(tmpX,tmpY));

    ax{3} = axes('Position',ax{1}.Position .* [1 1 0 1] + [-axS.xSpace.*.9  0 axS.xSpace.*.9  0]  );
    h = histogram(tmpY,linspace(yLims(1),yLims(2),11),'orientation','horizontal'); hold on
    [splineHandle] = PlotHistSpline(h,'LineWidth',2,'Color','b')
    set(ax{3},'xdir','r')
    box off
    ylim(yLims);
    title([yDefs{iMet} ' ' rowDefs{iRow}]);

end
end
sgtitle(['sub-network structure. ' regTypes{iReg} ' Regularization'])

f.(['PCAangles' regTypes{iReg}]).f        = figure('Position',[50,20,400,1800]); 
for iRow = 1:numel(rowDefs) 

% Also plot angle distributions
allAnglePm = acos(alldotProdPm);
allAngleBs = acos(alldotProdBs);


subplot(numel(rowDefs) ,2,(iRow -1) .* 2 + 1)
allAngToPl = squeeze(allAngleBs(:,1:15,iRow,iReg,1,1,:));
h = polarhistogram(real(allAngToPl),13,'Normalization','probability'); hold on
[splineHandle] = PlotHistSpline(h,'LineWidth',2,'Color','b')
rLims = rlim;
pAx = gca;
pAx.ThetaLim = [0 180];
title('angle between goal and threat')

subplot(numel(rowDefs) ,2,(iRow -1) .* 2 + 2)
allAngToPl = squeeze(allAnglePm(:,1:15,iRow,iReg,1,1,:));
h = polarhistogram(real(allAngToPl),13,'Normalization','probability'); hold on
[splineHandle] = PlotHistSpline(h,'LineWidth',2,'Color','b')
title('permuted angle between goal and threat')
rlim(rLims);
pAx = gca;
pAx.ThetaLim = [0 180];

end
sgtitle(['encoding orthogonality. ' regTypes{iReg} ' Regularization']);

end


%% Figure 5c: encoding orthogonality, scatter plots
%  Plots examples of first 3 PCs for each neuron type and regularization
%  type
%
% NOTE: if running small nets, this also plots the polar plots from extended data
% fig 3

% =======================
% OPTION A: main text, BIG NETWORKS
netSize     = 'BigNets';
neurTypes   = {'tansig'};
regTypes    = {'No'};
az = 39.0563;
el = 52.8667;
binEdges = -25:2.5:7.5;
iRun = 3;
iM = 2;

% % =======================
% % OPTION B, supplementary: SMALL NETWORKS (multiple artificial neuron types)
% netSize     = 'SmallNets';
% neurTypes   = {'tansig','logsig','softmax','poslin','purelin','tribas','radbas'};
% regTypes    = {'Valence_51','L1'};
% regTypes    = {'No','L1'};
% az = -74.3145;
% el = 43.0968;
% binEdges = -15:2.5:15;
% iRun = 1;
% iM = 1;

f.NeurTypesPCAExamples.f = figure('Position',[20 -20 1600 600]);

cOrder      = {[0 0 .7], [.7 0 0], [.8 .6 0]};
s.wrld.size = [14 15];
iV    = 1;
iPl  = 1;

for iTyp = 1:length(neurTypes) % Neuron type
    for iReg =  1:length(regTypes) % Regularisation type

        % Load neural activity
        load(['Results\ForFigures\Valence\NetworkActivations\' ...
            'FullNetActivity_NeurType_' neurTypes{iTyp} '_RegType_' regTypes{iReg} '_Run_' num2str(iRun) '_NetArch_' num2str(iM) '_' netSize '.mat']);

        % Create flattened activations for PCA
        glByThrActFlat = permute(glByThrAct,[1 2 3 6 7 4 5]);
        unwrapSize     = size(glByThrActFlat);
        glByThrActFlat = permute(glByThrActFlat(:,:,:,:,:,:),[6 1 2 3 4 5]);
        glByThrActFlat = glByThrActFlat(:,:);

        % Create 'explanatory variables'
        thrRow = repmat( (1:s.wrld.size(1))' , [1, size(glByThrAct,[1 2 3 7]) ] );
        thrRow = permute(thrRow, [2 3 4 1 5]);
        golRow = repmat( (1:s.wrld.size(1))' , [1, size(glByThrAct,[2 3 6 7]) ] );
        golRow = permute(golRow, [1 2 3 4 5]);

        % Perform PCA
        [coeff,score,~,~,explained] = pca(glByThrActFlat( ~isnan(glByThrActFlat(:,1)),:)');
        % Replace with zero if the PCA doesn't work
        if size(score,2) == 0
            score = zeros([size(glByThrActFlat,2) 3]);
        end

        % Downsample only a little
        tmpScore = reshape(score', [size(score,2) unwrapSize(1:5)] );
        tmpScore = tmpScore(:,:,2:2:end,1:2:end,:,2:2:end);
        tmpScore = tmpScore(:,:)';

        for iVar = 1:2


            subplot(numel(neurTypes), numel(regTypes).*2, iPl);
            iPl = iPl + 1;

            if iVar == 1
                tmpCl = golRow(:,2:2:end,1:2:end,:,2:2:end);
            elseif iVar == 2
                tmpCl = thrRow(:,2:2:end,1:2:end,:,2:2:end);
            end
            tmpCl = tmpCl(:);
            tmpSz = 5;
            value_min = min(tmpCl);
            value_max = max(tmpCl);

            colormap_name = 'jet'; % You can use any built-in colormap or create a custom one
            nrmCl = (tmpCl - value_min) / (value_max - value_min); % Normalize data to [0, 1]
            if iVar == 1
                color_map = colormap(coltocol(100,[0.2 0.2 0.2],[0 0 0.7])); % Apply the colormap to the normalized data
            elseif iVar == 2
                color_map = colormap(coltocol(100,[0.2 0.2 0.2],[0.7 0 0])); % Apply the colormap to the normalized data
            end
            colors = interp1(linspace(0, 1, size(color_map, 1)), color_map, nrmCl); % Interpolate colors
            scatter3(tmpScore(:,1), tmpScore(:,2), tmpScore(:,3), tmpSz , colors , 'filled');
            if iVar == 1
                title('Colour = goal row correlation')
            elseif iVar == 2
                title('Colour = threat row correlation')
            end

        end

    end
end


%% STATS: relationship between structure/orthogonality and reconstruction quality

if ~exist('netSize', 'var') || strcmp(netSize,'BigNets')
    disp('Loading Small Network results first. Please wait')
    netSize = 'SmallNets';
    try
        load(['Results\ForFigures\Fig5_ExtDatFig3_model6_Base_Processed_' netSize '_Precomputed.mat' ]);
    catch
        warning('No Precomputed data found for the small networks. Either Compute results using CreateDataForPlots.m, or download precompted results from $')
    end
end

allPerfAll          = repmat(allPerf,[1 1 1 1 4]);
tStatsStructureAll  = repmat(tStatsStructure,[1 1 1 1 4]);
absalldotProd       = abs(alldotProd);
absalldotProdAll    = repmat(absalldotProd,[1 1 1 1 4]);

inclD = ~isnan(absalldotProdAll(:)) & ~isnan(allPerfAll(:)) & ~isnan(rhoAllNewTasks(:)) & ~isnan(tStatsStructureAll(:)); 

disp(' ')
[rhoStruct pStruct] = partialcorr(tStatsStructureAll(inclD), rhoAllNewTasks(inclD), [allPerfAll(inclD) absalldotProdAll(inclD)]);
[r_low, r_high] = corrCI(rhoStruct, sum(inclD), 0.05);
disp('Partial correlation between Structure t-stat and Reconstruction quality: ');
disp(['P = ' num2str(pStruct) '. rho = ' num2str(rhoStruct) ' (95% CI: ' num2str(r_low) '-' num2str(r_high)]);

disp(' ')

[rhoStruct pStruct] = partialcorr(absalldotProdAll(inclD), rhoAllNewTasks(inclD), [allPerfAll(inclD) tStatsStructureAll(inclD)]);
[r_low, r_high] = corrCI(rhoStruct, sum(inclD), 0.05);
disp('Partial correlation between Orthogonality and Reconstruction quality: ');
disp(['P = ' num2str(pStruct) '. rho = ' num2str(rhoStruct) ' (95% CI: ' num2str(r_low) '-' num2str(r_high)]);


%% Extended Data Figure 3, plot icons for neuron types

% Input strength range
x = -5:0.1:5;

% Initialize a figure
f.NeurTypesSketch.f         = figure('Position',[20 -20 300 900]);

for iT = 1:length(neurTypes)
    % Compute neuron output for given input strength
    switch neurTypes{iT}
        case 'tansig'
            y = tansig(x);
        case 'logsig'
            y = logsig(x);
        case 'softmax'
            y = softmax([x; -x]);
            y = y(1, :); % consider one dimension for display
        case 'poslin'
            y = poslin(x);
        case 'purelin'
            y = purelin(x);
        case 'tribas'
            y = tribas(x);
        case 'radbas'
            y = radbas(x);
        otherwise
            y = zeros(size(x));
    end
    
    % Create a subplot and plot the neuron's response
    subplot(7, 1, iT);
    plot(x, y, 'LineWidth', 1.5);
    title(neurTypes{iT});
    xlabel('Input Strength');
    ylabel('Output');
    grid on;
end

% Adjust layout
tight_layout = true;
if tight_layout
    sgtitle('Response Functions of Various Neuron Types');
end

%% Save figures

allFields = fields(f);
for iF = 1:length(allFields)
    cF = allFields{iF};
    
    set(f.(cF).f, 'Renderer', 'painters'); % default, opengl
    saveas(f.(cF).f,['Results\Outputs\Figure5_' cF '.png'] , 'png')
    saveas(f.(cF).f,['Results\Outputs\Figure5_' cF '.eps'] , 'epsc')
    saveas(f.(cF).f,['Results\Outputs\Figure5_' cF '.pdf'] , 'pdf')
end
