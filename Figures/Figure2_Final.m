% -----
% USE:
% 
% - Run this script to re-create:
% -- The elements used for making Figure 2 of the main paper
% -- The statistical results related to Figure 2
%
% - % - The data necessary for this figure is generated by CreateDataForPlots_Final.m,
% !HOWEVER! a pre-computed version can also be loaded (much faster) from:
% ~~~~~~~~~~~~~~~ https://doi.org/10.5281/zenodo.16408688 ~~~~~~~~~~~~~~~
% -----

% First make sure the path is set right
cFileName                   = matlab.desktop.editor.getActiveFilename;
codePath                    = cFileName(1:end-24);
addpath(                    genpath(codePath));


% NOTE: Change this to the file path where you store the generated data,
% whether downloaded or generated by yourself
dataPath                    = ''; %'C:\Users\Rory Bufacchi\Documents\Projects\DefenseAgent'; '';
if                          isempty(dataPath)
     dataPath                   = SetPathEgocentricMapsData();
end
cd(                         dataPath);

%% LOAD DATA for Fig2, abc part
%  NOTE: Load this if not computing the ANN outputs yourself
try
    load('Results\ForFigures\Fig2abc_Results_Precomputed.mat')
catch
    warning('No Precomputed data found. Either Compute results using CreateDataForPlots.m, or download precompted results from $')
end

%% STATS: Action values correlate with limb-object proximity

disp(       '-----------')
disp(       'Action values correlate with limb-object proximity:')
[rMat_All]  = DisplayProxStats(rSAll);
disp(        'NOTE: See figure title for stats on predominance of bodypart-centred neurons PER LAYER')


%% STATS: Proportion of neurons with bodypart-centred receptive fields

disp(       '-----------')
disp(       'Proportion of neurons in each considered network: ');
disp(       num2str(rMat_All.propCorrNeur));
disp(       'Average Proportion: ')
disp(       [num2str(nanmean(rMat_All.propCorrNeur)) '+-' num2str(nanstd(rMat_All.propCorrNeur))] );


%% STATS: Proportion of bodypart-centred neurons in last layer

for iM      = 1:length(rSAll)
    llCorr(iM)  = rMat_All.propCorrNeurPerLay(length(rSAll(iM).s.lp.netS),iM);
end
disp(       ['Last layer: ' num2str(nanmean(llCorr)) '+-' num2str(nanstd(llCorr)) ])


%% Fig2abc - Individual neural activity 


% PLOT EMPIRICAL DATA
% =========================================================================
% -------------------------------------------------------------------------
cM                          = 4;
f.NeurA.f                   = figure('Position',[20 20 1200 1400]);
f.NeurA.ax{1}               = axes('Position',[.1 .8 .2 .15 ]);
tmpFig                      = imread('Results\ForFigures\JPGs\BrainAreas.jpg');
alphaChan                   = ~all(tmpFig > 250, 3);
image(                      tmpFig,'AlphaData',alphaChan); axis off


% -------------------------------------------------------------------------
f.NeurA.ax{2}               = axes('Position',[.1 .45 .25 .25 ]);
monkeyDatLimb               = [0.231 0.058 0.342 0.145 0.145 0.051 0.145 0.145 0.232 0.117 0.056 0.559 0.432 0.138 0.237 0.537 0.329 0.548 0.435 0.644 0.851 0.770 0.340 0.224 0.546 0.434 0.645 0.544 1.269 1.591 1.374 1.072 1.480 1.374 0.967 1.061 1.164 0.967 1.366 1.183 0.863 0.961 1.164 1.063 0.546 0.653 ; ...
                               0.243 0.131 0.058 0.338 0.121 0.121 0.050 0.232 0.346 0.240 0.047 0.863 0.135 0.749 0.329 1.067 0.445 1.156 0.340 0.641 0.953 0.432 0.227 0.522 0.329 0.741 0.660 1.158 0.743 1.374 1.072 1.480 0.746 1.480 0.967 1.061 1.686 1.379 1.076 1.270 0.937 0.648 1.171 1.062 0.950 0.539 ; ...
                               0.121 0.227 0.109 0.045 0.128 0.049 0.049 0.132 0.231 0.049 0.461 0.461 0.114 0.227 0.947 0.637 0.322 0.730 0.448 0.937 0.324 0.644 0.851 0.529 0.323 0.213 0.938 0.229 0.846 0.329 0.837 1.586 1.269 1.374 1.266 1.266 0.736 0.736 0.736 0.545 1.061 0.837 0.740 1.063 0.936 0.419];
monkeyDatLimb               = (monkeyDatLimb ./ 0.975) .*50;
monkeyTimes                 = [1:size(monkeyDatLimb,2)] ./ 1.2 - .38;
tmpD                        = nanmean(monkeyDatLimb);
tmpX                        = [1:length(tmpD)] - length(tmpD)/2;
tmpGaus                     = normpdf(tmpX,14,8);
imagesc(                    [tmpGaus' * movmean(tmpD,10)]');
f.NeurA.ax{2}.XAxis.Visible = 'off';
f.NeurA.ax{2}.YAxis.Visible = 'off';
title(                      'Real Limb-centred Neuron')
box                         off


% -------------------------------------------------------------------------
f.NeurA.ax{3}               = axes('Position',[.375 .45 .075 .25 ]);
f.NeurA.RealBarsLimb        = bar(monkeyTimes, nanmean(monkeyDatLimb),'FaceColor','flat'); hold on; box off
f.NeurA.RealBarsLimb.CData  = zeros(size(f.NeurA.RealBarsLimb.CData));
plot(                       [0 0], [0 1.8],'-.k')
view(                       [90 90])
f.NeurA.ax{3}.XAxis.Visible = 'off';
ylabel(                     'Activity (Hz)')



% -------------------------------------------------------------------------
% Use the monkeydatlimb, and smear it in the x-direction,
% using Imagesc
monkeyDatHead =             [0.240 0.174 0.0588 0.091 0.129 0.092 0.092 0.053 0.025 0.053 0.136 0.061 0.0160 0.129 0.058 0.094 0.053 0.167 0.098 0.125 0.094 0.049 0.089 0.056 0.037 0.125 0.099 0.245 0.164 0.245 0.195 0.096 0.240 0.158 0.059 0.244 0.127 0.089 0.197 0.125 0.316 0.348 0.237 0.125 0.424 0.308 0.240 .0309 0.424 0.277 0.348 0.421 0.280 0.193 0.238 0.346 0.428 0.384 0.447 0.535 0.316 0.535 0.353 0.384 0.500 0.417 0.752 0.707 0.672 0.787 0.787 0.752 0.719 0.676 0.786 0.646 0.856 0.721 0.823 0.823 0.823 0.496 0.669 0.669 0.494 1.009 0.602 0.642 0.716 0.501 0.449 ; ...
                             0.450 0.421 0.235 0.079 0.039 0.1988 0.051 0.046 0.046 0.014 0.080 0.018 0.084 0.084 0.044 0.018 0.023 0.0880 0.047 0.124 0.013 0.084 0.084 0.051 0.086 0.047 0.047 0.047 0.084 0.047 0.047 0.084 0.047 0.120 0.080 0.125 0.088 0.125 0.059 0.117 0.082 0.112 0.086 0.160 0.087 0.113 0.164 0.087 0.120 0.311 0.193 0.235 0.120 0.271 0.165 0.125 0.369 0.304 0.408 0.374 0.412 0.417 0.231 0.458 0.369 0.523 0.523 0.627 0.598 0.667 0.530 0.744 0.528 0.738 0.698 0.959 0.823 1.112 0.856 0.954 0.924 1.042 0.967 0.608 0.667 0.601 0.648 0.860 0.431 0.745 0.415 ];
monkeyDatHead               = (monkeyDatHead ./ 0.73) .*100;
monkeyTimes                 = [1:size(monkeyDatHead,2)] ./ (1/5) - .22;
f.NeurA.ax{4}               = axes('Position',[.1 .1 .25 .25 ]);
tmpD                        = nanmean(monkeyDatHead);
tmpX                        = [1:length(tmpD)] - length(tmpD)/2;
tmpGaus                     = normpdf(tmpX,-27,15);
imagesc(                    [tmpGaus' * movmean(tmpD,10)]');
f.NeurA.ax{4}.YAxis.Visible = 'off';
title(                      'Real Head-centred Neuron')
box                         off

% -------------------------------------------------------------------------
f.NeurA.ax{5}               = axes('Position',[.375 .1 .075 .25 ]);
f.NeurA.RealBarsHead        = bar(monkeyTimes, nanmean(monkeyDatHead),'FaceColor','flat'); hold on; box off
f.NeurA.RealBarsHead.CData  = zeros(size(f.NeurA.RealBarsHead.CData));
plot(                       [0 0], [0 1.8],'-.k')
view(                       [90 90])
f.NeurA.ax{5}.XAxis.Visible = 'off';
ylabel(                     'Activity (Hz)')

            

% MODELLED DATA
% =========================================================================
% -------------------------------------------------------------------------
f.NeurA.ax{6}               = axes('Position',[.6 .8 .2 .15 ]);
tmpFig                      = imread('Results\ForFigures\JPGs\NeurNET.jpg');
alphaChan                   = ~all(tmpFig > 250, 3);
image(                      tmpFig,'AlphaData',alphaChan); axis off


% -------------------------------------------------------------------------
f.NeurA.ax{7}               = axes('Position',[.6 .45 .25 .25 ]);
CM                          = 4;
s                           = rS(cM).s;
w                           = rS(cM).w;

% Specific demonstration neurons which look nice for PRECOMPUTED neural nets
cL                          = 4;
cN                          = 2;

% Plot settings
s.plt.intrpFact             = 1;
s.plt.plAct                 = 1;
s.plt.lmbCol                = 11;
s.plt.meanLimbCols          = 0;
s.plt.bdyCol                = 2:14;
s.plt.pltType               = 'Imagesc';
DisplActValsFun(            s,w,-neurActForPlot_MeanBody(:,:,:,:,cL,cN));
colorbar                    off
box                         off
xlabel(                     'Stimulus x-position'); 
ylabel(                     'Stimulus y-position');
title(                      'Artificial limb-centred neuron')
caxis(                      [-.7 .6]);
ylim(                       [1.5 9.5]);
xlim(                       [3 13]);

fS.gridXstart               = -4.5;
fS.gridXstep                = 1;
fS.gridYstart               = 3.5;
fS.gridYstep                = 1;
GridOverImage(              fS,f.NeurA.ax{7});

% -------------------------------------------------------------------------
f.NeurA.ax{8}               = axes('Position',[.875 .45 .075 .25 ]);
allLC                       = 2:14;
clear                       tmpPlt
for iLC                     = 1:length(allLC)
    cLC                         = allLC(iLC);
    tmpPlt(:,iLC)               = squeeze( nanmean(-neurActForPlot_MeanBody(w.bdy.row,cLC,:,cLC,cL,cN)   ,[2 4]  )  );
end
tmpPlt(9:end,:)             = NaN;
tmpPlt                      = abs(tmpPlt - nanmin(tmpPlt(:)));
f.NeurA.ModelBarsLimb       = bar([8:-1:1], nanmean(tmpPlt(1:8,:),2),'FaceColor','flat'); hold on; box off
f.NeurA.ModelBarsLimb.CData = zeros(size(f.NeurA.ModelBarsLimb.CData));
view(                       [90 -90])
xlim(                       [-.5 7.5])
f.NeurA.ax{8}.XAxis.Visible = 'off';
ylabel(                     'Activity')



% -------------------------------------------------------------------------
f.NeurA.ax{9}               = axes('Position',[.6 .1 .25 .25 ]);
CM                          = 4;

s                           = rS(cM).s;
w                           = rS(cM).w;

% Good neuron from PRECOMPUTED net that shows limb-centred field
cL                          = 4;
cN                          = 2;

% Plot settings
s.plt.intrpFact             = 1;
s.plt.plAct                 = 1;
s.plt.lmbCol                = 5;
s.plt.meanLimbCols          = 0;
s.plt.bdyCol                = 2:14;
s.plt.pltType               = 'Imagesc';
DisplActValsFun(            s,w,-neurActForPlot_MeanLimb(:,:,:,:,cL,cN));
colorbar                    off
box                         off
xlabel(                     'Stimulus x-position'); 
ylabel(                     'Stimulus y-position');
title(                      'Artificial body-centred neuron');
caxis(                      [-.6 .4]);
ylim(                       [1.5 9.5]);
xlim(                       [3 13])
GridOverImage(              fS,f.NeurA.ax{9});

% -------------------------------------------------------------------------
f.NeurA.ax{10}              = axes('Position',[.875 .1 .075 .25 ]);
allLC                       = 2:14;
clear                       tmpPlt
for iLC                     = 1:length(allLC)
    cLC                         = allLC(iLC);
    tmpPlt(:,iLC)               = squeeze( nanmean(-neurActForPlot_MeanLimb(w.bdy.row,cLC,:,cLC,cL,cN)   ,[2 4]  )  );
end
tmpPlt                      = tmpPlt - nanmin(tmpPlt(:));
f.NeurA.ModelBarsBody       = bar([8:-1:1], nanmean(tmpPlt(1:8,:),2),'FaceColor','flat'); hold on; box off
f.NeurA.ModelBarsBody.CData = zeros(size(f.NeurA.ModelBarsBody.CData));
view(                       [90 -90])
xlim(                       [-.5 7.5])
f.NeurA.ax{10}.XAxis.Visible = 'off';
ylabel(                     'Activity');


% -------------------------------------------------------------------------
f.LPos.ax{11}               =  axes('Position',[.6 .43 .25 .1 ]);
tmpFig                      = imread('Results\ForFigures\JPGs\MonkeyTopDown1Pose.jpg');
alphaChan                   = ~all(tmpFig > 250, 3);
image(                      tmpFig,'AlphaData',alphaChan); axis off

% -------------------------------------------------------------------------
f.LPos.ax{12}               = axes('Position',[.6 .08 .25 .1 ]);
tmpFig                      = imread('Results\ForFigures\JPGs\MonkeyTopDown1Pose.jpg');
alphaChan                   = ~all(tmpFig > 250, 3);
image(                      tmpFig,'AlphaData',alphaChan); axis off

% -------------------------------------------------------------------------
f.NeurA.ax{13}              = axes('Position',[.1 .43 .25 .1 ]);
tmpFig                      = imread('Results\ForFigures\JPGs\MonkeyTopDown1Pose.jpg');
alphaChan                   = ~all(tmpFig > 250, 3);
image(                      tmpFig,'AlphaData',alphaChan); axis off

% -------------------------------------------------------------------------
f.NeurA.ax{14}              = axes('Position',[.1 .08 .25 .1 ]);
tmpFig                      = imread('Results\ForFigures\JPGs\MonkeyTopDown1Pose.jpg');
alphaChan                   = ~all(tmpFig > 250, 3);
image(                      tmpFig,'AlphaData',alphaChan); axis off

% -------------------------------------------------------------------------
yRange                      = .2;
fS.nBins                    = 4;
fS.pltType                  = 'bar';


% create depth groups so that I can make pie charts
clear                       splGroups
for iM                      = 1:length(rS)
    nLay                    = length(rS(iM).s.lp.netS);
    grSize                  = round(nLay./fS.nBins);
    cInd                    = 1;
    for iSpl                = 1:fS.nBins-1
        splGroups{iM,iSpl}      = cInd : iSpl .* grSize;
        cInd                    = iSpl.* grSize + 1;
    end
    splGroups{iM,iSpl + 1}  = cInd : nLay;
end

for iSpl                    = 1:fS.nBins    
    f.NeurA.ax{15 + iSpl-1} = axes('Position', [.85 (.75 + (iSpl-1) .* (yRange/fS.nBins)) .1 (yRange/fS.nBins) ]);
    for iM                  = 1:length(rS)
        cL                      = splGroups{iM,iSpl};
        propNeurs(iM,iSpl)      = nanmean(rMat.propCorrNeurPerLay(cL,iM),[2 1]);
    end   
    p                       = pie([1 - nanmean(propNeurs(:,iSpl),1); nanmean(propNeurs(:,iSpl),1)]);
    colormap(               coltowhite(100,[0 0 1]));
    set(                    p,'EdgeColor','k')
    
    if iSpl                 == 1
        l                   = legend('% proximity-dependent units');
        l.Position          = l.Position - [.1 .02 0 0];
    end
end
xlabel(                     'binned layer depth')
ylabel(                     'binned proportion of neurons that correlate with proximity')
view(                       [90 90]);
colormap(                   f.NeurA.ax{9}, whitetocol(100,[0 .6 0]));




%% LOAD DATA for Fig2, defg part
%  NOTE: Load this if not computing the ANN outputs yourself
try
    load('Results\ForFigures\Fig2defg_model2_Processed_Precomputed.mat')
catch
    warning('No Precomputed data found. Either Compute results using CreateDataForPlots.m, or download precompted results from $')
end

%% STATS: Q-value dependence on Speed

overThresh = NaN([3 9 4]);
clear rRL pRL allRL allOverThresh

for iM = 1:4 %length(rS)    
    for iAct = 1:1 % rS(iM).s.act.numA    
        clear overThresh tmpRL
        
        % lC sR sC cL rL
        % qTmp = squeeze(Qall(end,:,:,:,iAct,:,:,iM));
        qTmp = squeeze(nanmean(Qall(end,:,:,:,:,:,:,iM),5));
                
        % Find the extent of the field for each limb column
        lCs = 2:14;
        for iLC = 1:length(lCs)
            cLC = lCs(iLC);
            Qline = squeeze(nanmean(qTmp(cLC,:,cLC,:,:),[1 3 4]));   
            qThresh = prctile(Qline(:),90);
              
            for iRL = 1:size(Qline,2) % loop through ROW LAGS to find expansion size
                try
                    overThresh(iRL,iLC) = find(Qline(:,iRL) > qThresh,1);
                catch
                    overThresh(iRL,iLC) = NaN;
                end
                tmpRL(iRL,iLC) = iRL;
            end
        end      
        allRL(:,:,iAct,iM)         = tmpRL;
        allOverThresh(:,:,iAct,iM) = overThresh;
        
        % Column Lag p-values
        [rTmp,pTmp,rLTmp,rUTmp] = corrcoef(tmpRL(~isnan(overThresh)),overThresh(~isnan(overThresh)));
        rRL(iAct,iM) = rTmp(2);
        pRL(iAct,iM) = pTmp(2);
    end
end

disp(['all rho: ' num2str(rRL)]);
[dmy pRL2] = fdr(pRL(1:4));
[maxP maxInd] = max(pRL2);
disp(['max p: ' num2str(maxP)])
disp(['weakest rho: ' num2str(rRL(maxInd))]);
disp(['mean rho: ' num2str(mean(rRL))]);
disp(['std rho: ' num2str(std(rRL))]);

%% STATS: Q-value dependence on Direction

clear rCL pCL allCL allOverThreshC tmpCL alloverThreshC overThreshC

for iM = 1:length(rS)    
    for iAct = 1:1 %rS(iM).s.act.numA
        
        clear overThresh tmpCL
        
        % lC sR sC cL rL
        % qTmp = squeeze(Qall(end,:,:,:,iAct,:,:,iM));
        qTmp = squeeze(nanmean(Qall(end,:,:,:,:,:,:,iM),5));
        
        qThresh = prctile(qTmp(:),50);
        
        % Find the extent of the field for each limb row
        sRs = 5:12;
        for iSR = 1:length(sRs)
            cSR = sRs(iSR);
            Qline = squeeze(nanmean(qTmp(2:14,cSR,2:end-1,:,:),[1 2 5]));
            % Make it absolute positive
            Qline = Qline - min(Qline,[],1);
            
            for iCL = 1:size(Qline,2) % loop through COLUMN LAGS to find extension size
                try
                    % Calculate center of mass
                    overThreshC(iCL,iSR) = sum(Qline(:,iCL).*(1:size(Qline,1))') ./ sum(Qline(:,iCL));
                catch
                    overThreshC(iCL,iSR) = NaN;
                end
                tmpCL(iCL,iSR) = iCL;
            end
        end
        % shift to mean for each limb column
        overThreshC = overThreshC - nanmean(overThreshC,1);
        
        allCL(:,:,iAct,iM)         = tmpCL;
        alloverThreshC(:,:,iAct,iM) = overThreshC;
        
        % Column Lag p-values
        [rTmp,pTmp,rLTmp,rUTmp] = corrcoef(tmpCL(~isnan(overThreshC)),overThreshC(~isnan(overThreshC)));
        rCL(iAct,iM) = rTmp(2);
        pCL(iAct,iM) = pTmp(2);
    end
end

[dmy pCL2] = fdr(pCL(1:4));
[maxP maxInd] = max(pCL2);
disp(['max p:' num2str(maxP)]);
disp(['weakest rho' num2str(rCL(maxInd))]);
disp(['mean rho:' num2str(mean(rCL))]);
disp(['std rho:' num2str(std(rCL))]);


%% STATS: Neural activity - dependence on Speed

% Find correlations of neurons with proximity
[rMat] = DisplayProxStats(rS_sepV(3).rS(1:4));

clear rRL pRL allRL alloverThreshFBN

rRLN                = nan([11,50,4]);
pRLN                = nan([11,50,4]);
allRLN              = nan([3,13,11,50,4]);
alloverThreshFBN    = nan([3,13,11,50,4]);

for iM = 1:4 %length(rS)
    for iL = 1:length(rS(iM).s.lp.netS) % Layers
        for iN = 1:rS(iM).s.lp.netS(iL) % Neurons

            clear overThreshFBN tmpRL

            % z-score, then flip depending on direction of correlation
            naTmp = sign(rMat.rDistN(iL,iN,iM)) .* squeeze(nAall(end,:,:,:,iL,iN,:,:,iM));
            naTmp = abs( (naTmp - nanmean(naTmp(:)))./nanstd(naTmp(:)) - nanmin(naTmp(:)) );

            % Find the extent of the field for each limb column
            lCs = 2:14;
            for iLC = 1:length(lCs)
                cLC = lCs(iLC);
                Qline = squeeze(nanmean(naTmp(cLC,:,cLC,:,:),[1 3 4]));
                naThresh = prctile(Qline(:),90);

                for iRL = 1:size(Qline,2) % loop through ROW LAGS to find expansion size
                    try
                        qLTmp = Qline(~isnan(Qline(:,iRL)),iRL);
                        overThreshFBN(iRL,iLC) = find(interp1(1:size(qLTmp,1),qLTmp,1:1:size(qLTmp,1)) > naThresh,1);
                    catch
                        overThreshFBN(iRL,iLC) = NaN;
                    end
                    tmpRL(iRL,iLC) = iRL;
                end
            end

            allRLN(:,:,iL,iN,iM)           = tmpRL;
            alloverThreshFBN(:,:,iL,iN,iM) = overThreshFBN;

            % Column Lag p-values
            [rTmp,pTmp,rLTmp,rUTmp] = corrcoef(tmpRL(~isnan(overThreshFBN)),overThreshFBN(~isnan(overThreshFBN)));
            if numel(rTmp) > 1
                rRLN(iL,iN,iM) = rTmp(2);
                pRLN(iL,iN,iM) = pTmp(2);
            else
                % don't assign p-values if only 1 value
                rRLN(iL,iN,iM) = NaN;
                pRLN(iL,iN,iM) = NaN;
            end
        end
    end
end
disp(' ')
disp(' -------------------- ')
disp('Proportion of row lag neurons overall')
rMat.overallRLneurProp = ...
                 sum(rMat.pDistN<0.05 & ...
                     pRLN<0.05 ,[1 2]) ./ sum(rMat.pDistN<0.05,[1 2]);
disp(['Mean: ' num2str(nanmean(rMat.overallRLneurProp)) ', Std: ' num2str(nanstd(rMat.overallRLneurProp))]);




%% STATS: Neural activity - dependence on Direction

[rMat] = DisplayProxStats(rS_sepV(1).rS(1:4));

clear rCLN pCLN allCLN allOverThreshCN tmpCL alloverThreshCN overThreshCN
overThreshCLN       = NaN([3 11 50 4]);
rCLN                = nan([11,50,4]);
pCLN                = nan([11,50,4]);
allCLN              = nan([5,11,11,50,4]); % col lag, stim row, layer, neuron, model
alloverThreshCN     = nan([5,11,11,50,4]);

for iM = 1:length(rS)
    
    
    for iL = 1:length(rS(iM).s.lp.netS)
        for iN = 1:rS(iM).s.lp.netS(iL)
        
        clear overThreshC tmpCL
        
        % lC sR sC cL rL
        naTmp = sign(rMat.rDistN(iL,iN,iM)) .* squeeze(nAall(end,:,:,:,iL,iN,:,:,iM));
        naTmp = abs( (naTmp - nanmean(naTmp(:)))./nanstd(naTmp(:)) - nanmin(naTmp(:)) );
        
        naThresh = prctile(naTmp(:),50);
        
        % Find the extent of the field for each limb row
        sRs = 2:12;
        for iSR = 1:length(sRs)
            cSR = sRs(iSR);
            
            Qline = squeeze(nanmean(naTmp(2:13,cSR,2:end-1,:,:),[1 2 5]));
            qThresh = prctile(Qline(:),90);

            for iCL = 1:size(Qline,2) % loop through COLUMN LAGS to find extension size
                try
                    overThreshCN(iCL,iSR) = sum(Qline(:,iCL).*(1:size(Qline,1))') ./ sum(Qline(:,iCL));
                catch
                    overThreshCN(iCL,iSR) = NaN;
                end
                tmpCL(iCL,iSR) = iCL;
            end
        end
        
        % shift to mean for each limb column
        overThreshCN = overThreshCN - nanmean(overThreshCN,1);
        allCLN(:,:,iL,iN,iM)          = tmpCL;
        alloverThreshCN(:,:,iL,iN,iM) = overThreshCN;
        
        % Column Lag p-values
        [rTmp,pTmp,rLTmp,rUTmp] = corrcoef(tmpCL(~isnan(overThreshCN)),overThreshCN(~isnan(overThreshCN)));
        rCLN(iL,iN,iM) = rTmp(2);
        pCLN(iL,iN,iM) = pTmp(2);
        
        end 
    end
    
end

% Then put the data into rMat
rMat.pColLagLN      = pCLN;
rMat.rColLagLN      = rCLN;
rMat.propCLExpNeur = nan([11,4]); % neurons whose field Rxpands with distance
rMat.propCorrAndCLNeur = nan([11,4]); % neurons who 'have a field' and it expands with distance
rMat.propOfCorrCLNeur = nan([11,4]); % porportion of neurons which have a field that expand
rMat.propOfCorrVELNeur = nan([11,4]); % porportion of neurons which have a field that depends on all velocity things

for iM = 1:length(rS)
    for iL = 1:length(rS(iM).s.lp.netS)
        for iN = 1:rS(iM).s.lp.netS(iL)
                        
            rMat.propCLExpNeur(1:length(rS(iM).s.lp.netS),iM) = ...
                sum(pCLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2) ./ (rS(iM).s.lp.netS)';
            
            rMat.propCorrAndCLNeur(1:length(rS(iM).s.lp.netS),iM) = ...
                sum(rMat.pDistN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                pCLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2) ./(rS(iM).s.lp.netS)';
            
            rMat.propOfCorrCLNeur(1:length(rS(iM).s.lp.netS),iM) = ...
                sum(rMat.pDistN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                pCLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2) ./ sum(rMat.pDistN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2);
            
            rMat.propOfCorrVELNeur(1:length(rS(iM).s.lp.netS),iM) = ...
                 sum(rMat.pDistN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                     pCLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                     pRLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2) ./ sum(rMat.pDistN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2);
                 
             rMat.propCorrAndVELNeur(1:length(rS(iM).s.lp.netS),iM) = ...
                 sum(rMat.pDistN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                     pCLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                     pRLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2) ./ (rS(iM).s.lp.netS)';
                 
             rMat.propCorrNotAnyVELNeur(1:length(rS(iM).s.lp.netS),iM) = ...
                 sum(rMat.pDistN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                     pCLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05 & ...
                     pRLN(1:length(rS(iM).s.lp.netS),:,iM)<0.05,2) ./ (rS(iM).s.lp.netS)';
        end
    end

end

disp(' ')
disp(' -------------------- ')
disp('Proportion of velocity neurons (row lag & column lag)')
rMat.overallVELneurProp = ... proportion of bodypart-centred neurons
                 sum(rMat.pDistN<0.05 & ...
                     pCLN<0.05 & ...
                     pRLN<0.05,[1 2]) ./ sum(rMat.pDistN<0.05,[1 2]);
% rMat.overallVELneurProp = ... Porportion of all neurons
%                  sum(rMat.pDistN<0.05 & ...
%                      pCLN<0.05 & ...
%                      pRLN<0.05,[1 2]) ./ sum(rMat.pDistN<100,[1 2]);
disp([num2str(nanmean(rMat.overallVELneurProp)) ' +- ' num2str(nanstd(rMat.overallVELneurProp))]);

disp(' ')
disp(' -------------------- ')
disp('Proportion of row lag neurons')
rMat.overallRLneurProp = ... proportion of bodypart-centred neurons
                 sum(rMat.pDistN<0.05 & ...
                     pRLN<0.05 ,[1 2]) ./ sum(rMat.pDistN<0.05,[1 2]);
% rMat.overallRLneurProp = ... Porportion of all neurons
%                  sum(pRLN<0.05 ,[1 2]) ./ sum(rMat.pDistN<100,[1 2]);
disp([num2str(nanmean(rMat.overallRLneurProp)) ' +- ' num2str(nanstd(rMat.overallRLneurProp))]);

disp(' ')
disp(' -------------------- ')
disp('Proportion of column lag neurons ')
rMat.overallCLneurProp = ... proportion of bodypart-centred neurons
                 sum(rMat.pDistN<0.05 & ...
                     pCLN<0.05 ,[1 2]) ./ sum(rMat.pDistN<0.05,[1 2]);
% rMat.overallCLneurProp = ... Porportion of all neurons
%                  sum(pCLN<0.05 ,[1 2]) ./ sum(rMat.pDistN<100,[1 2]);
disp([num2str(nanmean(rMat.overallCLneurProp)) ' +- ' num2str(nanstd(rMat.overallCLneurProp))]);


%% Fig2def - Kinematic effects

% =========================================================================
% Plot heatmaps

f.Speed.f = figure('Position',[20 20 1200 400]);
cM = 1;

sFP = DefaultSettings(rS(cM).s);
net = rS(cM).net;
w   = rS(cM).w;

sFP.plt.lmbCol         = 2:14;
sFP.plt.stimRow        = [1:size(w.world2D,1)];
sFP.plt.stimCol        = [2:size(w.world2D,1)];
sFP.plt.rowLims        = [1.5 13.5];
sFP.plt.meanLimbCols   = 1;
sFP.plt.plAct          = 2;
sFP.plt.rowLag = 1;
sFP.plt.colLag = 0;
sFP.plt.intrpFact = 1;
fS.gridXstart = -4.5;
fS.gridXstep = 1;
fS.gridYstart = 3.5;
fS.gridYstep = 1;

cDat = [0 0 1 ; .5 0 .5 ; .7 0 0];

allRowLags = rS(cM).s.gol.alSpR;
allColLags = rS(cM).s.gol.alSpC;

% -------------------------------------------------------------------------
% Plot velocity effect
plotRowLags = {[1] , [2], [3]};
plotColLags = {[-2:2] , [-2:2], [-2:2]};
nPlts       = length(plotRowLags);
plNames     = {'Slow','Medium','Fast'};
for iPl = 1:nPlts    
    vAx{iPl} = subplot(1,nPlts,iPl);

    % Plot average over all models
    qTemp = nanmean(QallOrig(:,:,:,:,:,...
        find(ismember(allColLags,plotColLags{iPl})),...
        find(ismember(allRowLags,plotRowLags{iPl})),  1: end-1 ),[6 7 8]);
    
    for iAct = 1:length(qTemp)
        qTemp(:,:,:,:,iAct) = nanmean(qTemp,5);
    end
    
    DisplActValsFun(sFP,w,qTemp); hold on
    caxis([0 2])
    colorbar off
    GridOverImage(fS,vAx{iPl});
    xLims = xlim;
    yLims = ylim;
    plot([0 0],yLims,'-.k')
    plot(xLims,[10.5 10.5],'-.k')
    
    vAx{iPl}.YAxis.Visible = 'off';
    vAx{iPl}.Box = 'off';
    
    title(plNames{iPl})

    
    % 1 Dimensional extent plot
    if iPl == nPlts
        axb = axes('Position',[ [vAx{1}.Position(1:2) + [vAx{1}.Position(3).*.1 vAx{1}.Position(4).*.5 ] ] [ vAx{1}.Position(3:4).*[0.3 .4]] ] ,'Box','off');
        tmpD = allOverThresh(:,:);
        b = bar(12 - nanmean(tmpD(:,:),2),'FaceColor','flat'); hold on
        b.CData = cDat;
        for iiPl = 1:nPlts
        plot([iiPl iiPl]', 12 - [nanmean(tmpD(iiPl,:),2) - nanstd(tmpD(iiPl,:),[],2)./2  ...
            nanmean(tmpD(iiPl,:),2) + nanstd(tmpD(iiPl,:),[],2)./2  ]',...
            'k','LineWidth',2);

        end
        boxplot(12-tmpD');
        plotRowAveragesWithSpread(12 - tmpD);
        ylim([0 8])
        axb.XAxis.Visible = 'off';
        axb.Box = 'off';
        title('Field Size')
        xlim([.5 3.5])
    end
end
for iPl = 1:nPlts
    colormap(vAx{iPl},whitetocol(100,cDat(iPl,:)));
end
sgtitle('Value fields expand in response to faster stimuli')

% -------------------------------------------------------------------------
% Plot direction effect

plotRowLags = {[1:3] , [1:3] , [1:3]};
plotColLags = { 2 0 -2 };
nPlts       = length(plotRowLags);
plNames     = {'Left','Center','Right'};
f.Dir.f = figure('Position',[20 20 1200 400]);
for iPl = 1:nPlts
        dAx{iPl} = subplot(1,nPlts,iPl);
        
        % Plot average over all models
        qTemp = nanmean(QallOrig(:,:,:,:,:,...
            find(ismember(allColLags,plotColLags{iPl})),...
            find(ismember(allRowLags,plotRowLags{iPl})),  1: end-1 ),[6 7 8]);
        
        for iAct = 1:length(qTemp)
            qTemp(:,:,:,:,iAct) = nanmean(qTemp,5);
        end
        
        DisplActValsFun(sFP,w,qTemp); hold on
        yLims = ylim;
        plot([0 0],yLims,'-.k')
        caxis([0 2])
        colorbar off
        GridOverImage(fS,vAx{iPl});
        xLims = xlim;
        yLims = ylim;
        plot([0 0],yLims,'-.k')
        plot(xLims,[10.5 10.5],'-.k')
        
        dAx{iPl}.YAxis.Visible = 'off';
        dAx{iPl}.Box = 'off';
        
        title(plNames{iPl})
        
        % 1 Dimensional extent plot
        cCL = find(ismember(allColLags,plotColLags{iPl}));
        axb = axes('Position',[ [vAx{iPl}.Position(1:2) + [vAx{iPl}.Position(3).*.25 vAx{iPl}.Position(4).*.7 ] ] [ vAx{iPl}.Position(3:4).*[0.5 .2]] ] ,'Box','off');
        tmpD = -alloverThreshC(:,:);
        b = bar(- nanmean(tmpD(cCL,:),2),'FaceColor',cDat(1,:)); hold on
        plot([1 1]', - [nanmean(tmpD(cCL,:),2) - nanstd(tmpD(cCL,:),[],2)./2  ...
             nanmean(tmpD(cCL,:),2) + nanstd(tmpD(cCL,:),[],2)./2  ]',...
             'k','LineWidth',2); 
        ylim([-2 2])
        axb.XAxis.Visible = 'off';
        axb.Box = 'off';
        view([90 -90])
        title('Field Extent')
        

end
colormap(whitetocol(100,cDat(2,:)));

sgtitle('Value field shape depend on stimulus direction')


% =========================================================================
% Make a venn diagram of neuron sensitivity
addpath([codePath 'Utilities\plotting'])

f.OverallProp.f = figure('Position',[20 20 400 400]);

rMat.overallPropNeur = ...
                 sum(rMat.pDistN<0.05 ,[1 2]) ./ sum(~isnan(rMat.pDistN),[1 2]);
rMat.overallVELneurOfCorrProp = ...
                 sum(rMat.pDistN<0.05 & ...
                     pCLN<0.05 & ...
                     pRLN<0.05,[1 2]) ./ sum(rMat.pDistN<0.05,[1 2]);
rMat.overallRLneurOfCorrProp = ...
                 sum(rMat.pDistN<0.05 & ...
                     pRLN<0.05 ,[1 2]) ./ sum(rMat.pDistN<0.05,[1 2]);
rMat.overallCLneurOfCorrProp = ...
                 sum(rMat.pDistN<0.05 & ...
                     pCLN<0.05 ,[1 2]) ./ sum(rMat.pDistN<0.05,[1 2]);
rMat.overallVELneurAndCorrProp = ...
                 sum(rMat.pDistN<0.05 & ...
                     pCLN<0.05 & ...
                     pRLN<0.05,[1 2]) ./ sum(~isnan(rMat.pDistN),[1 2]);
rMat.overallRLneurAndCorrProp = ...
                 sum(rMat.pDistN<0.05 & ...
                     pRLN<0.05 ,[1 2]) ./ sum(~isnan(rMat.pDistN),[1 2]);
rMat.overallCLneurAndCorrProp = ...
                 sum(rMat.pDistN<0.05 & ...
                     pCLN<0.05 ,[1 2]) ./ sum(~isnan(rMat.pDistN),[1 2]);

disp(' ')
disp(' -------------------- ')
disp('Proportion of velocity neurons overall')
rMat.overallVELneurProp = ...
                 sum(pCLN<0.05 & ...
                     pRLN<0.05,[1 2]) ./ sum(~isnan(rMat.pDistN),[1 2]);
disp([num2str(nanmean(rMat.overallVELneurProp)) ' +- ' num2str(nanstd(rMat.overallVELneurProp))]);
disp(' ')
disp(' -------------------- ')
disp('Proportion of row lag neurons overall')
rMat.overallRLneurProp = ...
                 sum(pRLN<0.05 ,[1 2]) ./ sum(~isnan(rMat.pDistN),[1 2]);
disp([num2str(nanmean(rMat.overallRLneurProp)) ' +- ' num2str(nanstd(rMat.overallRLneurProp))]);
disp(' ')
disp(' -------------------- ')
disp('Proportion of column lag neurons overall')
rMat.overallCLneurProp = ...
                 sum(pCLN<0.05 ,[1 2]) ./ sum(~isnan(rMat.pDistN),[1 2]);
disp([num2str(nanmean(rMat.overallCLneurProp)) ' +- ' num2str(nanstd(rMat.overallCLneurProp))]);

[H S] = venn([nanmean(rMat.overallPropNeur), nanmean(rMat.overallCLneurProp), nanmean(rMat.overallRLneurProp)], ...
    [nanmean(rMat.overallCLneurAndCorrProp) nanmean(rMat.overallRLneurAndCorrProp) nanmean(rMat.overallVELneurProp) nanmean(rMat.overallVELneurAndCorrProp)]);

tmpA = sum(S.CircleArea) - sum(S.IntersectArea(1:3)) + 2.*S.IntersectArea(end);

hold on;
t = linspace(0, 2*pi);
r = sqrt(tmpA./pi);
x = r*cos(t) + .138;
y = r*sin(t)+ .045;
patch(x, y, 'g','FaceAlpha',.1);
axis equal;

cAx = gca; 
cAx.Visible = 'off';

legend('Body-part centred', 'velocity-sensitive','direction-sensitive','all');


%% LOAD DATA for Fig2, hij part
%  NOTE: Load this if not computing the ANN outputs yourself
try
    load('Results\ForFigures\Fig2hij_model3_Processed_Precomputed.mat')
catch
    warning('No Precomputed data found. Either Compute results using CreateDataForPlots.m, or download precompted results from $')
end

%% STATS: Correlation between tool training time and number of peaks

sFP = incrToolRS(1,1).s;
% Calculate number of peaks without a tool --------------------------------
clear toolPks noToolPks
for iM = 1:size(incrToolRS,1)
    for iD = 1:size(incrToolRS,2)
        toolPks(iD,iM,:)     = incrToolRS(iM,iD).npks;
        sFP.plt.ToolPresent = 0;
        [noToolPks(iD,iM,:), dmy1, dmy2]  = ...
            RowPeakFind(sFP,QallNoTool(:,:,:,:,:,iM,iD,1));
    end
end

% Effect of training ------------------------------------------------------
batchNum = repmat((1:size(toolPks,1))',[1 size(toolPks,2) size(toolPks,3)]);
tmpX = permute(batchNum,[2 1 3]); tmpX = tmpX(:,:);
tmpY = permute(toolPks,[2 1 3]);  tmpY = tmpY(:,:);
[rhorho pp] = corr(tmpX',tmpY');
pp = pp(1,:);
rhorho = rhorho(1,:);
[dmy1 dmy2 pp] = fdr(pp);

[maxP maxInd] = max(pp(:));
disp(' ')
disp('-------------')
disp(['Minimum correlation, p: ' num2str(maxP)] );
disp(['Minimum correlation, rho: ' num2str(rhorho(maxInd))]);
disp(['mean rho: ' num2str(nanmean(rhorho))]);
disp(['std rho: ' num2str(nanstd(rhorho))]);


%% STATS: After tool training, number of peaks with/without tool 

% Display stats for number of tool fields 
disp(' ')
disp('-------------')
disp('After training, tool vs no tool:')
[pTl hTl stats] = signrank(toolPks(end,:),noToolPks(end,:),'method','approximate');
effSizR1 = stats.zval ./ sqrt(numel(toolPks(end,:).*2));

disp(['mean peaks without tool: ' num2str(mean(noToolPks(end,:)))]);
disp(['sd without tool: ' num2str(std(noToolPks(end,:)))]);
disp(['mean peaks with tool: ' num2str(mean(toolPks(end,:)))]);
disp(['sd with tool: ' num2str(std(toolPks(end,:)))]);
disp(' ');
disp(['P: ' num2str(pTl)]);
disp(['Z-value: ' num2str(stats.zval)]);
disp(['eff size R1: ' num2str(effSizR1)]);


%% STATS: After tool training, proportion of tool-sensitive neurons

% Effect of training ------------------------------------------------------
% Convert format to match legacy analyses
olRS                = incrToolRS(:,1); % Only limb (no tool) results
ytRS                = incrToolRS(:,end); % 'yes tool' results
[rMatOL]            = DisplayProxStats(olRS);
[rMatYT]            = DisplayProxStats(ytRS);
nPksNLikeOld        = cat(5,npksNnoTool(:,:,:,:,1),npksN(:,:,:,:,1),npksNnoTool(:,:,:,:,end),npksN(:,:,:,:,end));
rMatOL.npksN        = nPksNLikeOld;
rMatYT.npksN        = nPksNLikeOld; 
rMat.nPeaksPerNeur  = squeeze(nanmean(nPksNLikeOld(:,:,:,:,:),[1]));
rMat.peaksPerLay    = squeeze(nanmean(nPksNLikeOld(:,:,:,:,:),[1 2]));

for iM = 1:length(olRS)
    for iL = 1:length(olRS(iM).s.lp.netS)
        rMat.peakDifferencesPreTrain(:,iL,iM)              = rMat.nPeaksPerNeur(iL,:,iM,2) - rMat.nPeaksPerNeur(iL,:,iM,1);
        rMat.peakDifferencesPostTrain(:,iL,iM)             = rMat.nPeaksPerNeur(iL,:,iM,4) - rMat.nPeaksPerNeur(iL,:,iM,3);
        rMat.peakDifferencesProPostTrainWithTool(:,iL,iM)  = rMat.nPeaksPerNeur(iL,:,iM,4) - rMat.nPeaksPerNeur(iL,:,iM,2);
        
        rMat.propOfCorrToolRespPreTrain(iL,iM) = nansum(rMat.peakDifferencesPreTrain(:,iL,iM) > 0 & ...
            rMatOL.pDistN(iL,:,iM)' < 0.05) ./ nansum(rMatOL.pDistN(iL,:,iM)' < 0.05);
        rMat.propOfCorrToolRespPostTrain(iL,iM) = nansum(rMat.peakDifferencesPostTrain(:,iL,iM) > 0 & ...
                    rMatOL.pDistN(iL,:,iM)' < 0.05) ./ nansum(rMatOL.pDistN(iL,:,iM)' < 0.05);
        % Proportion of neurons that got more peaks after tool training than before tool training
        rMat.propOfCorrToolRespPrePostTrain(iL,iM) = nansum(rMat.peakDifferencesProPostTrainWithTool(:,iL,iM) > 0 & ...
                    rMatOL.pDistN(iL,:,iM)' < 0.05) ./ nansum(rMatOL.pDistN(iL,:,iM)' < 0.05);
    end
end
close all;

opts.testType = 'lme';
[figString rhoVal pVal fullStats] = CorrelationTitle(rMatOL.relLayDep,rMat.propOfCorrToolRespPrePostTrain,opts);
figure, plot (rMatOL.relLayDep,rMat.propOfCorrToolRespPrePostTrain,'-o','LineWidth',2);
title(figString);
xlabel('Relative layer depth')
ylabel('Proportion of tool use PPS neurons')

disp(' ');
disp('-------------------------')
disp(['Relationship between neural layer PPS-and tooluse-ness: ' figString]);disp(' ') 


disp('-------------------------')
disp('Overall proportion of tool sensitive neurons: ')
rMat.OverallPropOfCorrToolRespPrePostTrain = nansum(rMat.peakDifferencesProPostTrainWithTool(:,:,iM) > 0 & ...
                    permute(rMatOL.pDistN,[2 1 3]) < 0.05 ,[1 2]) ./ nansum( permute(rMatOL.pDistN,[2 1 3]) < 0.05 , [1 2]);
disp([num2str(nanmean(rMat.OverallPropOfCorrToolRespPrePostTrain)) '+ -' num2str(nanstd(rMat.OverallPropOfCorrToolRespPrePostTrain))]);

disp('-------------------------')
disp('Last layer proportion of tool sensitive neurons: ')
disp([num2str(nanmean(rMat.propOfCorrToolRespPrePostTrain')) '+ -' num2str(nanstd(rMat.propOfCorrToolRespPrePostTrain'))]);


%% Fig2hij - Effects of learning to use tools on Q-fields 

% -------------------------------------------------------------------------
% Calculate Incremental performance improvements
iM = 1;
plotReps = 1:51;

toolPerfs = cell2mat(arrayfun(@(iR) [incrToolRS(1,iR).perf.rewPerAct(end,1) ... 
                                     incrToolRS(2,iR).perf.rewPerAct(end,1) ... 
                                     incrToolRS(3,iR).perf.rewPerAct(end,1)], ...
                                     plotReps, 'UniformOutput', false)');

% -------------------------------------------------------------------------
% Plot tool results: line plots
fS.lineYLim = [-1 0.01 ];
fS.lineXLim = [-0.8  0];
fS.xPoints  = [5 5 ; 10 10]';
fS.cAxes    = [-1.8 1.8];

fS.gridXstart   = -5.5;
fS.gridXstep    =  1;
fS.gridYstart   =  2.5;
fS.gridYstep    =  1;

f.Tool.f = figure('Position',[20 20 1200 600]);

% plot performance
yyaxis right

mnPrf = mean(toolPerfs,2);
sdPrf = std(toolPerfs,0,2);
plot(mnPrf','r-o','LineWidth',2); hold on
opts.c = [.7 0 0];
ShadedPlot((1:51),mnPrf,mnPrf - sdPrf, mnPrf + sdPrf,opts);

ylim([0 .3])

ylabel('Reward per timestep')

% iM = 1; iD = 23;
clear allPks
for iM = 1:size(incrToolRS,1)
    for iD  = 1:size(incrToolRS,2)
        allPks(iD,iM,:)     = incrToolRS(iM,iD).npks;
        mnPks(iM,iD)        = nanmean(incrToolRS(iM,iD).npks);
        sdPks(iM,iD)        = nanstd(incrToolRS(iM,iD).npks);
        prcTilePks(:,iM,iD)   = prctile(incrToolRS(iM,iD).npks,[5 95]);
    end 
end
allPks2 = allPks;
allPks  = allPks(:,:);

% Average across model architectures
mnPks2 = mnPks;
mnPks  = nanmean(mnPks);
sdPks = sdPks ./ sqrt(size(allPks2,3)); % convert to standard error
sdPks  = sum(sqrt(sdPks .^2 ));

yyaxis left
[N C] = hist3( [repmat(  (1:size(allPks,1))', [size(allPks,2) 1]), allPks(:) ],[51 3]);


f.Tool.ax{1} = gca;

plot(mnPks','b-o','LineWidth',2); hold 
plot(mnPks2');
opts.c = [0 0 .7];
opts.PlotMean = 0;
ShadedPlot((1:51),mnPks,mnPks - sdPks,mnPks + sdPks,opts);
plot(mnPks','b-o','LineWidth',2); hold 

ylim([0.8 3])
xlabel('Training batch since exposure to tool')
ylabel('Number of peaks in receptive field')

title('A receptive field grows around the tooltip as the agent learns to use the tool')

xlim([0 51])
box off

% -------------------------------------------------------------------------
% Plot tool results: receptive fields
sFP.plt.pltType             = 'Imagesc';
sFP.plt.ON                  = 1;
sFP.plt.meanLimbCols        = 1;
sFP.plt.rowLims             = [1.5 13.5];
incrToolRS(1).s.plt.lmbCol  = 8;

% Plot the tool-fields as the agent learns
plBatchs = [1 2 3 7 51];
% Space out the sub-plots equally along the x-axis
subPlotxPos = f.Tool.ax{1}.Position(3) ./ (numel(plBatchs) + 1 );  
cAx = 2;



for iPl = 1:length(plBatchs)

    % Make an inset plot
    f.Tool.ax{cAx} = axes('Position', ... 
        f.Tool.ax{1}.Position .* [1, 1, 0, 0.2] + [ iPl .* subPlotxPos - subPlotxPos./2 ,  f.Tool.ax{1}.Position(4) .* 0.75 , subPlotxPos .* 0.8,  0]  );
    
    DisplActValsFun(sFP,incrToolRS(end,end).w,mean(Qall(:,:,:,:,:,:,plBatchs(iPl)),6));
    title(['Batch ' num2str(plBatchs(iPl))]);
    set(f.Tool.ax{cAx},'xTick',[])
    set(f.Tool.ax{cAx},'yTick',[])
    colorbar off
    caxis([0 2])
    GridOverImage(fS,gca);

    DrawLineBetweenAxes(f.Tool.ax{1},plBatchs(iPl), mnPks(plBatchs(iPl)), ...
                        f.Tool.ax{cAx}, 0, 1.5);

    % Make side plots
    MakeSidePlots(f.Tool.ax{cAx},mean(Qall(:,:,:,:,:,:,plBatchs(iPl)),6),fS,incrToolRS(1));
    cAx = cAx + 1;
end

colormap(whitetocol(100,[0 0 0.7 ],[1]));


%% Fig2hij - Effects of learning to use tools on neural activity 

f.ToolNeurs.f = figure('Position',[20 20 400 800]);
clear propNeurs
nSplits = size(rMat.propOfCorrToolRespPreTrain,1);
for iC = 1:1
for iSpl = 1:size(rMat.propOfCorrToolRespPreTrain,1)
    tmpD = rMat.propOfCorrToolRespPrePostTrain;
    for iM = 1:size(tmpD,2)
        propNeurs(iM,iSpl) = nanmean(tmpD(iSpl,iM),[2 1]);
        if propNeurs(iM,iSpl) == 0
            propNeurs(iM,iSpl) = .001
        end
    end
    
    subplot(nSplits,1,iSpl )
    p = pie([nanmean(propNeurs(:,iSpl),1) ; 1 - nanmean(propNeurs(:,iSpl),1)]);
    set(p,'EdgeColor','k')
    if iSpl == 1
        title('Proportion of Neurons with receptive fields that expand upon tool use');
    end
caxis([1 2]);
end
end
colormap(coltowhite(100,[0 0.2 .9]));


%% LOAD DATA for Fig2, klm part
%  NOTE: Load this if not computing the ANN outputs yourself
try
    load('Results\ForFigures\Fig2klm_model4_Processed_Precomputed.mat');
catch
    warning('No Precomputed data found. Either Compute results using CreateDataForPlots.m, or download precompted results from $')
end

%% STATS: Higher valence gives higher Q-values (kind of obvious tbh)

clear qVec
for iM = 1:length(rS)
    for iAct = 1:rS(1).s.act.numA
        for iV = 1:length(aTP)
            tmp = Q(1,2:end-1,1:11,2:end-1,iAct,iM,iV);
            qVec(:,iV) = tmp(:);
        end
        % Perform stats to see which stimulus' q-value is higher
        opts.testType = 'signrank';
        [figString zVal(iAct,iM) pVal(iAct,iM)] = CorrelationTitle([],qVec,opts);
    end
end

pVal = CalcFDR(pVal);

[pMax pMaxInd] = max(pVal(:));

disp(['Higher reward gives bigger magnitude Q fields: ' ])
disp(['P <= ' num2str(pMax) '. |Z| >= |' num2str(zVal(pMaxInd)) '|' ])
disp(['mean Z: ' num2str(nanmean(zVal(:)))  '+-' num2str(nanstd(zVal(:)))]);
rVal = zVal ./ sqrt(numel(qVec));
disp(['effect size, |r| >= ' num2str(max(rVal(:)))]);


%% STATS: Higher Q-values make movement happen at a greater distance

clear rV pV allV tmpV allOverThresh overThresh
for iM = 1:length(rS)
    for iAct = 1:1 %rS(iM).s.act.numA
        clear overThresh tmpRL        
        % lC sR sC cL rL
        qTmp = squeeze(nanmean(Q(end,:,:,:,:,iM,:),5));
        % make it all positive so that it is easy to take ratios
        qTmp = qTmp - min(qTmp(:)); 
        qThresh = prctile(qTmp(:),90);        
        % Find the extent of the field for each limb column
        lCs = 2:14;
        for iLC = 1:length(lCs)
            cLC = lCs(iLC);
            Qline = squeeze(nanmean(qTmp(cLC,1:11,cLC,:,:),[1 3]));
            % relative contact relevance, with random noise
            relContRel(:,:,iLC,iM) = normcdf(Qline,qThresh,qThresh.*0.25);
            for iV = 1:size(relContRel,2)
                % Center of mass
                coM(iV,iLC,iM) = nansum(relContRel(:,iV,iLC,iM).*(1:size(relContRel,1))') ./ nansum(relContRel(:,iV,iLC,iM));
                % Point of first increase
                tmpFI = find(relContRel(:,iV,iLC,iM)>0.5,1);;
                if isempty(tmpFI)
                    pFI(iV,iLC,iM) = NaN;
                else
                    pFI(iV,iLC,iM) = find(relContRel(:,iV,iLC,iM)>0.5,1);
                end
            end
        end
    end
end

disp(' ')
disp('-----------------------')
disp('Higher absolute valence leads to actions being initiated when stimuli are further from the body:')
clear pActDist signRankActDist zActDist
for iM = 1:size(pFI,3)
%     [pTmp,hTmp,stats] = signrank(pFI(2,:,iM)-pFI(1,:,iM),'method','approximate');
    [pTmp,hTmp,stats] = signrank(pFI(2,:,iM),pFI(1,:,iM),'method','approximate');
    pActDist(iM) = pTmp;
    signRankActDist(iM) = stats.signedrank;
    zActDist(iM) = stats.zval;
end
[dmy pActCorr] = fdr(pActDist);
disp(['P <= ' num2str(max(pActCorr)) '. |Z| >= |' num2str(min(abs(zActDist))) '|' ])
disp(['mean Z: ' num2str(nanmean(zActDist(:)))  '+-' num2str(nanstd(zActDist(:)))]);
rVal = zVal ./ sqrt(numel(qVec));
disp(['effect size, |r| >= ' num2str( abs(max(  zActDist ./ sqrt(numel(pFI(:,:,1)))) ))]);


%% STATS: neural activation is higher when valence is higher?

testLC = 2:14;
clear tmpD
tmpD1 = permute(nAall(w.lmb.row,testLC,2:11,testLC,:,:,:,:),[5 6 7 8  1 2 3 4]);
tmpD1 = tmpD1(:,:,:,:,:);
allSD = nanstd(tmpD1,[],5);
A = (allSD(:,:,:,2) -  allSD(:,:,:,1)) ./ (allSD(:,:,:,2) +  allSD(:,:,:,1));
disp('--------------------')
disp('neural increase in response to higher valence stimuli')
[ppp hhh statss] = signrank(A(~isnan(A)));
disp(['P = ' num2str(ppp) '. Z = ' num2str(statss.zval) ])
disp(['Effect size, r = ' num2str( statss.zval ./ sqrt(sum(~isnan(A),'all')) ) ]);


%% Fig2klm - Effects of Valence magnitude on bodypart centred fields

% -------------------------------------------------------------------------
% Heatmaps and line plots
fS.gridXstart = -4.5;
fS.gridXstep = 1;
fS.gridYstart = 3.5;
fS.gridYstep = 1;
f.ValenceMagnMap.f  = figure('Position',[20 20 600 400]);
f.ValenceMagnLine.f = figure('Position',[20 20 300 400]);
cM = 1;

sFP = DefaultSettings(rS(cM).s);
net = rS(cM).net;
w   = rS(cM).w;
sFP.plt.lmbCol         = 2:14;
sFP.plt.stimRow        = [1:size(w.world2D,1)];
sFP.plt.stimCol        = [2:size(w.world2D,1)];
sFP.plt.rowLims        = [1.5 13.5];
sFP.plt.meanLimbCols   = 1;
sFP.plt.plAct          = 2;
opts.FaceAlpha          = 0.3;
allRowLags = rS(cM).s.gol.alSpR;
condN = {'Low Valence' , 'High Valence'};
plCols = {[0 0 .7] , [0 0 0.7]};

for iCond = 1:2
    figure(f.ValenceMagnMap.f);
    ax{iCond} = subplot(1,2,iCond);
    sFP.plt.intrpFact = 1;
    qTemp = nanmean(Q(:,:,:,:,:,:,iCond),[6]);
    DisplActValsFun(sFP,w,qTemp); hold on
    GridOverImage(fS,ax{iCond});
    caxis([0 4])
    colorbar off
    title([condN{iCond}])
    box off

    figure(f.ValenceMagnLine.f);
    tmpM  = nanmean(relContRel(:,iCond,:),3);
    tmpSD = nanstd(relContRel(:,iCond,:),[],3);
    opts.c = plCols{iCond};
    ShadedPlot([size(relContRel,1):-1:1]',...
        tmpM,tmpM - tmpSD,tmpM + tmpSD, opts);
    xlabel('distance from limb')
    ylabel('Relative probability of contact-actions')
    ylim([0 1])
    xlim([1 8])
end
for iCond = 1:2
    colormap(ax{iCond},whitetocol(100,plCols{iCond}));
end
legend(condN)


% -------------------------------------------------------------------------
% Individual neuron responsiveness to valence
A = (allSD(:,:,:,2) -  allSD(:,:,:,1)) ./ (allSD(:,:,:,2) +  allSD(:,:,:,1));
f.VarIncrease.f = figure('Position',[20 20 300 400])
histogram(A(:),linspace(-1,1,5),'Normalization','probability'); hold on
yLims = ylim;
plot([0 0],yLims,'-.k')
title('Most neurons increase their variability when exposed to a more valuable stimulus')
xlabel('Change in neuron variability')
ylabel('probability')
box off


%% Save figures

if isfield(f,'LPos')
    f                           = rmfield(f,'LPos');
end

allFields                   = fields(f);
for iF                      = 1:length(allFields)
    cF                          = allFields{iF};
    set(                        f.(cF).f, 'Renderer', 'painters'); % default, opengl
    saveas(                     f.(cF).f,['Results\Outputs\Figure2_' cF '.png'] , 'png')
    saveas(                     f.(cF).f,['Results\Outputs\Figure2_' cF '.eps'] , 'epsc')
    saveas(                     f.(cF).f,['Results\Outputs\Figure2_' cF '.pdf'] , 'pdf')
end

%% FUNCTIONS

function [] = DrawLineBetweenAxes(ax_main,x_main,y_main, ax_sub,x_sub,y_sub)

    % Assuming ax_main and ax_sub are your main and subplot axes, and pt_main and pt_sub are the point coordinates in the respective axes
    pt_main = [x_main, y_main]; % Replace with actual main axes point
    pt_sub = [x_sub, y_sub]; % Replace with actual subplot point
    
    % Normalise units
    pt_main_normalized = [(pt_main(1) - ax_main.XLim(1)) / diff(ax_main.XLim), (pt_main(2) - ax_main.YLim(1)) / diff(ax_main.YLim)];
    pt_sub_normalized = [(pt_sub(1) - ax_sub.XLim(1)) / diff(ax_sub.XLim), (pt_sub(2) - ax_sub.YLim(1)) / diff(ax_sub.YLim)];
    
    pt_main_fig = ax_main.Position(1:2) + pt_main_normalized .* ax_main.Position(3:4);
    pt_sub_fig = ax_sub.Position(1:2) + pt_sub_normalized .* ax_sub.Position(3:4);
    
    % Draw the annotation line
    annotation('line', [pt_main_fig(1), pt_sub_fig(1)], [pt_main_fig(2), pt_sub_fig(2)] , 'LineStyle', '--' );
end


function [] = MakeSidePlots(baseAx,Q,fS,rS)

    Q = - Q;

    ax{1} = baseAx;

    % Plot average OR line through Q-values
    ax{2} = axes('Position',ax{1}.Position .* [1 1 1 0] + [0 -0.1 0 0.1]  );
    plQhoriz = flip(squeeze(nanmean(Q(1,rS.s.plt.lmbCol,:,3:end-2,:),[2 3 5]))); % lmb R, C, stim R, C, A
    plot((1:numel(plQhoriz))' - 0.5  , [plQhoriz],'-','LineWidth',2); hold on
    xLims = xlim;
    xlim([0 numel(plQhoriz) ]);
    hold on
    ylim(fS.lineYLim);
    grid on
    ax{2}.XAxis.Visible = 'off';
    ax{2}.YAxis.Visible = 'off';
    ax{3} = axes('Position',ax{1}.Position .* [1 1 0 1] + [-0.03 0 0.03 0]  );
    plQvert = squeeze(nanmean(Q(1,rS.s.plt.lmbCol,2:end-1,:,:),[2 4 5])); % lmb R, C, stim R, C, A
    plot( plQvert, (numel(plQvert):-1:1)' - 0.5 , '-','LineWidth',2); hold on
    xlim(fS.lineXLim);
    ylim([0 12])
    grid on
    ax{3}.XAxis.Visible = 'off';
    ax{3}.YAxis.Visible = 'off';

end